# üì± IT2010 - MOBILE APPLICATION DEVELOPMENT
## üéì FINAL EXAMINATION - COMPLETE SOLUTION GUIDE

---

## Table of Contents
1. [Question 01 - Knowledge Assessment](#question-01---knowledge-assessment)
2. [Question 02 - UI/UX Design](#question-02---uiux-design-and-analysis)
3. [Question 03 - Kotlin Development & Validation](#question-03---kotlin-development-and-form-validation)
4. [Question 04 - RecyclerView Implementation](#question-04---kotlin-development-and-recyclerview)

---

## QUESTION 01 - Knowledge Assessment
**Total Marks: 25** | **Part A: 10 Marks** | **Part B: 15 Marks**

### üìã Part A: Multiple Choice Questions (10 Marks)

**Q1. Which layer contains all essential hardware drivers (camera, keyboard, display)?**
- **Answer: C) Linux Kernel** ‚úÖ
- The Linux Kernel layer provides access to all hardware resources and contains essential drivers for all device components.

---

**Q2. What is the correct sequence of Android lifecycle methods when an app launches from a stopped state?**
- **Answer: A) onCreate() ‚Üí onStart() ‚Üí onResume()** ‚úÖ
- This is the standard lifecycle sequence when the activity transitions from stopped state to resumed (foreground) state.

---

**Q3. Which benefits does Fragment usage provide? (Select all that apply)**
- **Answer: B, C** ‚úÖ
  - ‚úì B) Easier data sharing with ViewModel
  - ‚úì C) Smoother navigation
- Fragments enable better UI management and data sharing within a single Activity through shared ViewModels.

---

**Q4. In the 60-30-10 color rule, what is the accent color used for?**
- **Answer: C) Accent color for highlights and buttons** ‚úÖ
- The color distribution: 60% primary (background), 30% secondary, 10% accent (interactive elements)

---

**Q5. What does the question mark (?) suffix mean in Kotlin variable declaration?**
- **Answer: B) ?** ‚úÖ
- The `?` makes a variable nullable in Kotlin: `var name: String?`

---

**Q6. What does R.java file contain?**
- **Answer: B) Contains resource IDs for all resources** ‚úÖ
- R.java is auto-generated by AAPT (Android Asset Packaging Tool) and provides IDs for programmatically accessing resources.

---

**Q7. Which lifecycle method is called when the activity is no longer visible to the user?**
- **Answer: B) onStop()** ‚úÖ
- `onStop()` is invoked when the activity is completely hidden from view.

---

**Q8. What is the key difference between DVM and ART?**
- **Answer: B) DVM uses JIT compilation, ART uses AOT** ‚úÖ
- **DVM:** Just-In-Time (JIT) compilation at runtime
- **ART:** Ahead-Of-Time (AOT) compilation during installation

---

**Q9. Which type of Intent explicitly specifies the exact component to be called?**
- **Answer: B) Explicit Intent** ‚úÖ
- Explicit Intents specify the exact Activity or Service by class name.

---

**Q10. Which method returns the total number of items in a RecyclerView adapter's dataset?**
- **Answer: A) getItemCount()** ‚úÖ
- This method is required to be implemented in all RecyclerView adapters.

---

### üìù Part B: Short Answer Questions (15 Marks)

| # | Question | Answer |
|---|----------|--------|
| 1 | What does AAPT stand for? | Android Asset Packaging Tool |
| 2 | Name the method used to observe LiveData changes | `observe()` or `observe(lifecycleOwner, Observer)` |
| 3 | In Kotlin, which keyword declares an immutable variable? | `val` |
| 4 | LinearLayout's default orientation is: | Vertical |
| 5 | Which lifecycle method is called before an activity is destroyed? | `onDestroy()` |
| 6 | Which Room annotation is used to insert data? | `@Insert` |
| 7 | What is the result of successful validation? | `Valid` or `ValidationResult.Valid` |
| 8 | Which component runs in the background without UI? | `Service` |
| 9 | Which method creates a Fragment's view in the lifecycle? | `onCreateView()` |
| 10 | Who are the target users for mainstream applications? | Mainstreamers |

---

## QUESTION 02 - UI/UX Design and Analysis
**Total Marks: 25** | **Part A: 10 Marks** | **Part B: 7 Marks** | **Part C: 8 Marks**

### üéØ Part A: Evaluation and Recommendation (10 Marks)

#### Approach A: Feature-Rich Dashboard ‚ùå

**Disadvantages:**
- ‚ö†Ô∏è **Overwhelming for mainstream users** - The majority of users find too many options confusing
- ‚ö†Ô∏è **Violates simplicity principles** - Complexity makes the app difficult to maintain and use
- ‚ö†Ô∏è **Poor mobile UX** - Difficult to use in real-world scenarios (busy streets, one-handed use, quick tasks)
- ‚ö†Ô∏è **Cognitive overload** - Users must process 12+ options before taking action
- ‚ö†Ô∏è **Negative emotional experience** - Users feel stressed rather than organized
- ‚ö†Ô∏è **Designed for experts only** - Not suitable for the majority user base
- ‚ö†Ô∏è **High maintenance costs** - More features = more bugs and support needed

**Advantages:**
- ‚úÖ All features immediately visible
- ‚úÖ May appeal to power users seeking quick feature access

---

#### Approach B: Simple Home Screen ‚úÖ

**Advantages:**
- ‚úÖ **Follows proven simplicity principles** - Focuses on core user needs only
- ‚úÖ **Designed for mainstreamers** - The 80% of users who "just want the app to work"
- ‚úÖ **Reduced cognitive load** - Users see only what matters most
- ‚úÖ **Optimized for mobile environments** - Perfect for outdoor shopping and in-store use
- ‚úÖ **Better emotional experience** - Users feel organized and in control
- ‚úÖ **Fewer navigation steps** - Reduced taps to complete primary tasks
- ‚úÖ **Industry best practices** - Follows progressive disclosure pattern
- ‚úÖ **Lower maintenance costs** - Cleaner, simpler codebase

**Disadvantages:**
- ‚ö†Ô∏è Advanced features require extra navigation
- ‚ö†Ô∏è May initially frustrate expert users

---

#### üèÜ RECOMMENDATION: Approach B (Simple Home Screen)

**Justification:**

> **"Mass appeal comes from focusing on the mainstream, not the experts."**

##### 1. **Mainstream User Focus**
The grocery shopping app's primary audience consists of mainstreamers who prioritize:
- Quick product search
- Cart management
- Order tracking
- Category browsing

These 4 core features cover 90% of use cases. Additional features don't significantly increase value for most users.

##### 2. **Mobile Context Consideration**

| Context | Requirement |
|---------|-------------|
| **In-store Usage** | Quick product lookup while shopping, fast cart access |
| **At Home** | Browse and plan orders without distraction |
| **Time-Constrained** | Fast task completion for busy professionals |

A cluttered interface frustrates users in all these scenarios.

##### 3. **Emotional & Psychological Benefits**
- Simplicity = Confidence (users feel in control)
- Clarity = Trust (reduces anxiety about making mistakes)
- Organization = Satisfaction (achieves goals quickly)
- Especially important for elderly users who may feel overwhelmed by complexity

##### 4. **Progressive Disclosure Strategy**
Advanced features (Loyalty Points, Store Locator, Recipes) remain accessible through a menu:
- Experts can find them easily
- Mainstream users aren't distracted
- Clean, uncluttered main interface

##### 5. **Business Value**
- Higher user satisfaction ‚Üí Better retention
- Easier to use ‚Üí More completed purchases
- Reduced support burden ‚Üí Cost savings
- Positive reviews ‚Üí Better app store ranking

##### 6. **Evidence-Based Design**
Real-world examples:
- **Model T Success:** Ford succeeded by offering "any color as long as it's black" (simple, focused)
- **iPhone Success:** Minimal home screen, features hidden in menus
- **Google Search:** One search box, 99% of features hidden

---

### üé® Part B: 60-30-10 Color Rule Application (7 Marks)

#### **Primary Color (60%) - Background & Main Surfaces**

**Choice:** Soft White or Light Gray (#F5F5F5)

**Usage Areas:**
- App background
- Product card backgrounds
- Main content areas
- Supporting UI surfaces

**Reasoning:**
- ‚úÖ Creates clean, uncluttered space for product images to stand out
- ‚úÖ Reduces eye strain during extended browsing sessions
- ‚úÖ Communicates freshness and cleanliness (grocery context)
- ‚úÖ Ensures product photos display accurately without color interference
- ‚úÖ Accessibility-friendly high contrast base

---

#### **Secondary Color (30%) - Supporting Elements**

**Choice:** Fresh Green (#4CAF50) OR Warm Orange (#FF9800)

**Usage Areas:**
- Navigation bars
- Section headers
- Category labels
- Price tags
- Status indicators

**Reasoning:**
- ‚úÖ **Green:** Suggests freshness, health, organic products (perfect for groceries)
- ‚úÖ **Orange:** Creates warmth and appetite appeal
- ‚úÖ Provides visual hierarchy without overwhelming
- ‚úÖ Guides attention to important information zones
- ‚úÖ Maintains excellent readability with sufficient contrast ratios

---

#### **Accent Color (10%) - Interactive Elements**

**Choice:** Vibrant Complementary Color
- If secondary is green: Bright Orange (#FF5722)
- If secondary is orange: Teal (#00BCD4)

**Usage Areas:**
- "Add to Cart" buttons
- "Checkout" button
- Special offer badges
- Notification dots
- Selected state indicators

**Reasoning:**
- ‚úÖ Creates clear, unmissable call-to-action
- ‚úÖ Drives user conversions through high visibility
- ‚úÖ High contrast ensures accessibility
- ‚úÖ Creates sense of urgency for promotions
- ‚úÖ Guides user through shopping journey logically

---

#### **Impact on User Experience**

| Aspect | Impact |
|--------|--------|
| **Clarity** | Strong contrast prevents confusion and aids task completion |
| **Efficiency** | Users quickly identify interactive elements |
| **Emotional** | Harmony creates pleasant, trustworthy environment |
| **Brand** | Consistency builds recognition and familiarity |
| **Accessibility** | Proper ratios ensure readability for all users including those with visual impairments |

---

### üé™ Part C: Five UI Elements for Product Card (8 Marks)

#### **1. üñºÔ∏è ImageView - Product Photo**

**Purpose:** Display high-quality product image

**Justification:**
- Visual recognition is crucial for grocery shopping
- Users need to see exactly what they're buying
- Images convey: freshness, packaging, size, condition better than text
- Mainstream users rely heavily on visual cues rather than reading descriptions
- **Accessibility:** Include content descriptions for screen readers

**Implementation Notes:**
- Use `android:scaleType="centerCrop"` for consistent display
- Implement image loading library (Glide/Picasso)
- Include placeholder while loading

---

#### **2. üìÑ TextView - Product Name & Description**

**Purpose:** Display product title and brief description

**Example:**
```
Organic Bananas - 1kg
Fresh, naturally ripened
```

**Justification:**
- Provides essential identification information
- Clear, readable font size (minimum 16sp) for elderly users
- Brief description reduces need to open detailed view
- Must be easily scannable
- **Accessibility:** Dark text on light background ensures high contrast

**Implementation Notes:**
- Use bold text for product name
- Regular weight for description
- Proper line spacing for readability

---

#### **3Ô∏è‚É£ üí∞ TextView - Price Display**

**Purpose:** Show current price prominently

**Example:**
```
Rs. 89.99
```

**Justification:**
- Price is the PRIMARY decision factor
- Must be immediately visible without clicking
- Use accent color or bold text to highlight
- Include currency symbol for clarity
- Builds trust through transparency
- Speeds decision-making for mainstream users
- **Accessibility:** Large text size (18-20sp) for easy reading

**Implementation Notes:**
- Use larger font size than product name
- Apply accent color for visual prominence
- Format price consistently across app

---

#### **4. üõí Button/ImageButton - "Add to Cart"**

**Purpose:** Quick action to add product to shopping cart

**Icon:** Shopping cart with + symbol

**Justification:**
- Enables one-tap purchase intent without navigation
- Critical for mobile shopping efficiency
- Users shopping in-store need speed
- Icon + text creates clear visual affordance
- Reduces friction in purchase journey
- Minimizes accidental clicks through proper sizing
- **Accessibility:** Large touch target (minimum 48dp) for easy tapping, especially for elderly users or gloved hands

**Implementation Notes:**
- Minimum size: 48x48dp for touch target
- Apply accent color (#FF5722)
- Include ripple effect feedback
- Test with one-handed use

---

#### **5. ‚ù§Ô∏è ImageButton/ToggleButton - "Add to Favorites/Wishlist"**

**Purpose:** Save products for later review/purchase

**Icon:** Heart (outline when unfavorited, filled when favorited)

**Justification:**
- Users often browse before buying
- Allows comparison shopping without immediate purchase pressure
- Emotional benefit - users feel organized and in control
- Toggle state provides clear visual feedback
- Builds user engagement and retention
- **Accessibility:** Sufficient spacing from other buttons to prevent mis-taps, clear visual state changes

**Implementation Notes:**
- Implement toggle animation
- Use distinct colors for states (outline vs filled)
- Provide haptic feedback on toggle
- Sync with backend for persistence

---

#### **Layout Structure for Product Card**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                     ‚îÇ
‚îÇ        [Product Image]              ‚îÇ  ‚Üê ImageView (high priority)
‚îÇ                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Product Name & Description          ‚îÇ  ‚Üê TextViews (scanning pattern)
‚îÇ Organic Bananas - 1kg              ‚îÇ
‚îÇ Fresh, naturally ripened            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Rs. 89.99                           ‚îÇ  ‚Üê Price TextView (decision point)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [Add to Cart]    [‚ù§Ô∏è Favorite]      ‚îÇ  ‚Üê Action Buttons (quick access)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

#### **Additional Cross-Element Justifications**

**Mobile Environment:**
- All elements sized for finger-friendly interaction
- Optimized for outdoor use and gloved hands
- Proper touch target sizes (48dp minimum)
- Reduced motion for performance

**Scanning Pattern (F-Pattern):**
- Image at top (eye catches first)
- Name/price in middle (natural reading flow)
- Actions at bottom (primary and secondary CTAs)

**Cognitive Load Management:**
- Limited information prevents overwhelming users
- Progressive disclosure through expandable details
- Clear visual hierarchy guides attention

**Performance Optimization:**
- Simple elements ensure fast scrolling
- Lightweight layout reduces memory usage
- Lazy loading support for images

---

## QUESTION 03 - Kotlin Development and Form Validation
**Total Marks: 25** | **Part A: 5 Marks** | **Part B: 10 Marks** | **Part C: 10 Marks**

### üèóÔ∏è Part A: Product Data Class (5 Marks)

#### **Primary Solution**

```kotlin
data class Product(
    val productId: String,
    val name: String,
    val price: Double,
    val category: String,
    val stockQuantity: Int,
    val imageUrl: String = "",
    val description: String = ""
)
```

**Field Explanations:**

| Field | Type | Purpose |
|-------|------|---------|
| `productId` | String | Unique identifier (e.g., "PROD001") - flexible for different ID formats |
| `name` | String | Product name displayed to users |
| `price` | Double | Product price with decimal precision |
| `category` | String | Category for filtering (e.g., "Fruits", "Dairy") |
| `stockQuantity` | Int | Available quantity in inventory |
| `imageUrl` | String | URL to product image (optional, default "") |
| `description` | String | Detailed product information (optional, default "") |

**Key Benefits:**
- ‚úÖ Data class provides `equals()`, `hashCode()`, `toString()`, `copy()`
- ‚úÖ Immutable by default (`val` properties)
- ‚úÖ Concise syntax compared to Java POJOs
- ‚úÖ Easy database mapping with Room

---

#### **Alternative Solution (with more details)**

```kotlin
data class Product(
    val id: Int = 0,
    val productId: String,
    val productName: String,
    val unitPrice: Double,
    val categoryName: String,
    val availableStock: Int,
    val brand: String = "Generic",
    val expiryDate: String = ""
)
```

This version includes:
- Database auto-increment ID
- Brand information
- Expiry date tracking
- More descriptive field names

---

### üì¶ Part B: OrderStatus Sealed Class (10 Marks)

#### **Complete Implementation**

```kotlin
sealed class OrderStatus {
    object Pending : OrderStatus()
    data class Shipped(val trackingNumber: String) : OrderStatus()
    data class Delivered(val deliveryDate: String) : OrderStatus()
}

fun getOrderStatusMessage(status: OrderStatus): String {
    return when (status) {
        is OrderStatus.Pending -> 
            "Your order has been received and is being processed. We'll notify you once it ships."
        
        is OrderStatus.Shipped -> 
            "Your order is on the way! Track it using: ${status.trackingNumber}"
        
        is OrderStatus.Delivered -> 
            "Your order was delivered on ${status.deliveryDate}. Thank you for shopping with us!"
    }
}
```

**Explanation:**

| Concept | Details |
|---------|---------|
| **Sealed Class** | Restricts inheritance - all subclasses must be defined in same file. Ensures exhaustive `when` expressions |
| **Object Pending** | Singleton object - no additional data needed for pending state |
| **Data Classes** | Shipped and Delivered carry associated data (tracking number and delivery date) |
| **When Expression** | Exhaustive - compiler ensures all cases are handled |
| **Smart Casting** | `status.trackingNumber` accessible due to `is` check - no explicit cast needed |

---

#### **Usage Example**

```kotlin
// Example 1: Pending order
val order1 = OrderStatus.Pending
println(getOrderStatusMessage(order1))
// Output: Your order has been received and is being processed...

// Example 2: Shipped order
val order2 = OrderStatus.Shipped("TRK123456789")
println(getOrderStatusMessage(order2))
// Output: Your order is on the way! Track it using: TRK123456789

// Example 3: Delivered order
val order3 = OrderStatus.Delivered("2025-11-14")
println(getOrderStatusMessage(order3))
// Output: Your order was delivered on 2025-11-14...
```

---

#### **Alternative Implementation with More States**

```kotlin
sealed class OrderStatus {
    object Pending : OrderStatus()
    object Processing : OrderStatus()
    data class Shipped(val trackingNumber: String, val carrier: String) : OrderStatus()
    data class Delivered(val deliveryDate: String) : OrderStatus()
    data class Cancelled(val reason: String) : OrderStatus()
}
```

---

### ‚úÖ Part C: Checkout Form Validation (10 Marks)

#### **Complete Validation Implementation**

```kotlin
sealed class ValidationResult {
    data class Empty(val errorMessage: String) : ValidationResult()
    data class Invalid(val errorMessage: String) : ValidationResult()
    object Valid : ValidationResult()
}

class CheckoutFormData(
    private val phoneNumber: String,
    private val address: String,
    private val postalCode: String
) {
    
    fun validatePhoneNumber(): ValidationResult {
        return when {
            phoneNumber.isEmpty() -> {
                ValidationResult.Empty("Phone number is required")
            }
            !phoneNumber.startsWith("07") -> {
                ValidationResult.Invalid("Phone number must start with 07")
            }
            phoneNumber.length < 10 -> {
                ValidationResult.Invalid("Phone number must be exactly 10 digits")
            }
            phoneNumber.length > 10 -> {
                ValidationResult.Invalid("Phone number must be exactly 10 digits")
            }
            !phoneNumber.all { it.isDigit() } -> {
                ValidationResult.Invalid("Phone number must contain only digits")
            }
            else -> {
                ValidationResult.Valid
            }
        }
    }
    
    fun validateAddress(): ValidationResult {
        return when {
            address.isEmpty() -> {
                ValidationResult.Empty("Delivery address is required")
            }
            address.trim().length < 10 -> {
                ValidationResult.Invalid("Address must be at least 10 characters long")
            }
            else -> {
                ValidationResult.Valid
            }
        }
    }
    
    fun validatePostalCode(): ValidationResult {
        return when {
            postalCode.isEmpty() -> {
                ValidationResult.Empty("Postal code is required")
            }
            postalCode.length != 5 -> {
                ValidationResult.Invalid("Postal code must be exactly 5 digits")
            }
            !postalCode.all { it.isDigit() } -> {
                ValidationResult.Invalid("Postal code must contain only digits")
            }
            else -> {
                ValidationResult.Valid
            }
        }
    }
}
```

**Validation Rules:**

| Field | Rules |
|-------|-------|
| **Phone Number** | Not empty, starts with 07, exactly 10 digits, only numbers |
| **Address** | Not empty, minimum 10 characters |
| **Postal Code** | Not empty, exactly 5 digits, only numbers |

---

#### **Usage in Activity**

```kotlin
class CheckoutActivity : AppCompatActivity() {
    
    private lateinit var edtPhone: EditText
    private lateinit var edtAddress: EditText
    private lateinit var edtPostalCode: EditText
    private lateinit var btnSubmit: Button
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_checkout)
        
        edtPhone = findViewById(R.id.edtPhone)
        edtAddress = findViewById(R.id.edtAddress)
        edtPostalCode = findViewById(R.id.edtPostalCode)
        btnSubmit = findViewById(R.id.btnSubmit)
        
        btnSubmit.setOnClickListener {
            submitCheckout()
        }
    }
    
    private fun submitCheckout() {
        val formData = CheckoutFormData(
            phoneNumber = edtPhone.text.toString(),
            address = edtAddress.text.toString(),
            postalCode = edtPostalCode.text.toString()
        )
        
        var validCount = 0
        
        // Validate phone number
        when (val phoneValidation = formData.validatePhoneNumber()) {
            is ValidationResult.Valid -> validCount++
            is ValidationResult.Invalid -> {
                edtPhone.error = phoneValidation.errorMessage
            }
            is ValidationResult.Empty -> {
                edtPhone.error = phoneValidation.errorMessage
            }
        }
        
        // Validate address
        when (val addressValidation = formData.validateAddress()) {
            is ValidationResult.Valid -> validCount++
            is ValidationResult.Invalid -> {
                edtAddress.error = addressValidation.errorMessage
            }
            is ValidationResult.Empty -> {
                edtAddress.error = addressValidation.errorMessage
            }
        }
        
        // Validate postal code
        when (val postalValidation = formData.validatePostalCode()) {
            is ValidationResult.Valid -> validCount++
            is ValidationResult.Invalid -> {
                edtPostalCode.error = postalValidation.errorMessage
            }
            is ValidationResult.Empty -> {
                edtPostalCode.error = postalValidation.errorMessage
            }
        }
        
        if (validCount == 3) {
            Toast.makeText(this, "Checkout successful!", Toast.LENGTH_SHORT).show()
            proceedToPayment()
        }
    }
    
    private fun proceedToPayment() {
        val intent = Intent(this, PaymentActivity::class.java)
        startActivity(intent)
    }
}
```

---

#### **Enhanced Validation (Optional)**

```kotlin
class CheckoutFormData(
    private val phoneNumber: String,
    private val address: String,
    private val postalCode: String
) {
    
    // Validate all fields at once
    fun validateAll(): Map<String, ValidationResult> {
        return mapOf(
            "phone" to validatePhoneNumber(),
            "address" to validateAddress(),
            "postal" to validatePostalCode()
        )
    }
    
    // Check if all validations pass
    fun isFormValid(): Boolean {
        return validateAll().values.all { it is ValidationResult.Valid }
    }
    
    // Get all error messages
    fun getErrorMessages(): List<String> {
        return validateAll().values
            .filterIsInstance<ValidationResult.Invalid>()
            .map { it.errorMessage }
    }
}
```

---

## QUESTION 04 - Kotlin Development and RecyclerView
**Total Marks: 25** | **Part A: 5 Marks** | **Part B: 12 Marks** | **Part C: 8 Marks**

### üìä Part A: Order Data Class (5 Marks)

#### **Primary Solution**

```kotlin
data class Order(
    val orderId: String,
    val orderDate: String,
    val totalAmount: Double,
    val orderStatus: String,
    val items: Int = 0
)
```

**Field Details:**

| Field | Type | Purpose | Example |
|-------|------|---------|---------|
| `orderId` | String | Unique order identifier | "ORD001" |
| `orderDate` | String | Order date (ISO format) | "2025-11-14" |
| `totalAmount` | Double | Total order amount | 2450.50 |
| `orderStatus` | String | Current status | "Delivered", "Shipped", "Pending" |
| `items` | Int | Number of items (optional) | 3 |

---

#### **Alternative Solution (Database-Ready)**

```kotlin
@Entity(tableName = "orders")
data class Order(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    
    @ColumnInfo(name = "orderId")
    val orderId: String,
    
    @ColumnInfo(name = "orderDate")
    val orderDate: String,
    
    @ColumnInfo(name = "totalAmount")
    val totalAmount: Double,
    
    @ColumnInfo(name = "orderStatus")
    val orderStatus: String,
    
    @ColumnInfo(name = "itemCount")
    val itemCount: Int = 0
)
```

---

### üé™ Part B: OrderAdapter Implementation (12 Marks)

#### **Complete OrderAdapter Code**

```kotlin
class OrderAdapter(
    private val orders: List<Order>,
    private val onViewDetailsClick: (Order) -> Unit
) : RecyclerView.Adapter<OrderAdapter.OrderViewHolder>() {
    
    inner class OrderViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val tvOrderId: TextView = view.findViewById(R.id.tvOrderId)
        val tvOrderDate: TextView = view.findViewById(R.id.tvOrderDate)
        val tvTotalAmount: TextView = view.findViewById(R.id.tvTotalAmount)
        val tvOrderStatus: TextView = view.findViewById(R.id.tvOrderStatus)
        val btnViewDetails: Button = view.findViewById(R.id.btnViewDetails)
        
        fun bind(order: Order) {
            tvOrderId.text = "Order #${order.orderId}"
            tvOrderDate.text = order.orderDate
            tvTotalAmount.text = "Rs. ${String.format("%.2f", order.totalAmount)}"
            tvOrderStatus.text = order.orderStatus
            
            // Set status color based on order status
            when (order.orderStatus.lowercase()) {
                "pending" -> tvOrderStatus.setTextColor(Color.parseColor("#FF9800"))
                "shipped" -> tvOrderStatus.setTextColor(Color.parseColor("#2196F3"))
                "delivered" -> tvOrderStatus.setTextColor(Color.parseColor("#4CAF50"))
                else -> tvOrderStatus.setTextColor(Color.parseColor("#666666"))
            }
            
            btnViewDetails.setOnClickListener {
                onViewDetailsClick(order)
            }
        }
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): OrderViewHolder {
        val layoutInflater = LayoutInflater.from(parent.context)
        val view = layoutInflater.inflate(R.layout.item_order, parent, false)
        return OrderViewHolder(view)
    }
    
    override fun onBindViewHolder(holder: OrderViewHolder, position: Int) {
        holder.bind(orders[position])
    }
    
    override fun getItemCount(): Int {
        return orders.size
    }
}
```

**Adapter Components:**

| Component | Purpose |
|-----------|---------|
| **ViewHolder** | Holds references to views in each item |
| **onCreateViewHolder()** | Called to create new ViewHolder instances |
| **onBindViewHolder()** | Binds data to ViewHolder views |
| **getItemCount()** | Returns total number of items |

---

#### **Usage in Activity**

```kotlin
class OrdersActivity : AppCompatActivity() {
    
    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: OrderAdapter
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_orders)
        
        recyclerView = findViewById(R.id.rvOrders)
        recyclerView.layoutManager = LinearLayoutManager(this)
        
        // Sample data
        val orders = listOf(
            Order("ORD001", "2025-11-14", 2450.50, "Delivered", 5),
            Order("ORD002", "2025-11-13", 1890.00, "Shipped", 3),
            Order("ORD003", "2025-11-12", 3200.75, "Pending", 8),
            Order("ORD004", "2025-11-11", 1550.25, "Delivered", 2)
        )
        
        adapter = OrderAdapter(orders) { order ->
            // Handle view details click
            navigateToOrderDetails(order)
        }
        
        recyclerView.adapter = adapter
    }
    
    private fun navigateToOrderDetails(order: Order) {
        Toast.makeText(this, "Viewing details for ${order.orderId}", Toast.LENGTH_SHORT).show()
        val intent = Intent(this, OrderDetailsActivity::class.java)
        intent.putExtra("ORDER_ID", order.orderId)
        startActivity(intent)
    }
}
```

---

#### **Layout File (item_order.xml)**

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp"
    android:background="#F5F5F5"
    android:layout_marginBottom="8dp">
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical">
        
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical">
            
            <TextView
                android:id="@+id/tvOrderId"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Order #ORD001"
                android:textStyle="bold"
                android:textSize="16sp"
                android:textColor="#000000" />
            
            <TextView
                android:id="@+id/tvOrderDate"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="2025-11-14"
                android:textSize="14sp"
                android:textColor="#666666"
                android:layout_marginTop="4dp" />
        </LinearLayout>
        
        <TextView
            android:id="@+id/tvOrderStatus"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Pending"
            android:textStyle="bold"
            android:textSize="14sp"
            android:paddingHorizontal="12dp"
            android:paddingVertical="4dp"
            android:background="@drawable/status_badge" />
    </LinearLayout>
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:layout_marginTop="12dp">
        
        <TextView
            android:id="@+id/tvTotalAmount"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Rs. 2450.50"
            android:textStyle="bold"
            android:textSize="16sp"
            android:textColor="#FF5722" />
        
        <Button
            android:id="@+id/btnViewDetails"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="View Details"
            android:backgroundTint="#4CAF50"
            android:textSize="12sp"
            android:paddingHorizontal="16dp" />
    </LinearLayout>
</LinearLayout>
```

---

### üèóÔ∏è Part C: OrderViewModel Implementation (8 Marks)

#### **Complete ViewModel Implementation**

```kotlin
class OrderViewModel(private val orderDao: OrderDao) : ViewModel() {
    
    // Get all orders sorted by date (descending - newest first)
    val allOrders: LiveData<List<Order>> = orderDao.getAllOrdersSortedByDate()
    
    // Get orders filtered by status
    fun getOrdersByStatus(status: String): LiveData<List<Order>> {
        return orderDao.getOrdersByStatus(status)
    }
    
    // Search orders by ID
    fun searchOrders(searchQuery: String): LiveData<List<Order>> {
        return orderDao.searchOrders("%$searchQuery%")
    }
    
    // Insert new order (runs in background thread)
    fun insertOrder(order: Order) {
        viewModelScope.launch(Dispatchers.IO) {
            orderDao.insertOrder(order)
        }
    }
    
    // Delete an order
    fun deleteOrder(order: Order) {
        viewModelScope.launch(Dispatchers.IO) {
            orderDao.deleteOrder(order)
        }
    }
    
    // Get single order by ID
    fun getOrderById(orderId: String): LiveData<Order?> {
        return liveData {
            emit(orderDao.getOrderById(orderId))
        }
    }
}
```

---

#### **OrderViewModelFactory**

```kotlin
class OrderViewModelFactory(private val orderDao: OrderDao) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(OrderViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return OrderViewModel(orderDao) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}
```

---

#### **Room DAO Interface**

```kotlin
@Dao
interface OrderDao {
    
    @Query("SELECT * FROM orders ORDER BY orderDate DESC")
    fun getAllOrdersSortedByDate(): LiveData<List<Order>>
    
    @Query("SELECT * FROM orders WHERE orderStatus = :status ORDER BY orderDate DESC")
    fun getOrdersByStatus(status: String): LiveData<List<Order>>
    
    @Query("SELECT * FROM orders WHERE orderId LIKE :query ORDER BY orderDate DESC")
    fun searchOrders(query: String): LiveData<List<Order>>
    
    @Query("SELECT * FROM orders WHERE orderId = :orderId LIMIT 1")
    suspend fun getOrderById(orderId: String): Order?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrder(order: Order)
    
    @Update
    suspend fun updateOrder(order: Order)
    
    @Delete
    suspend fun deleteOrder(order: Order)
    
    @Query("DELETE FROM orders")
    suspend fun clearAllOrders()
}
```

---

#### **Room Database Setup**

```kotlin
@Database(entities = [Order::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    
    abstract fun orderDao(): OrderDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "grocery_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

---

#### **Complete Usage in Activity**

```kotlin
class OrdersActivity : AppCompatActivity() {
    
    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: OrderAdapter
    private lateinit var viewModel: OrderViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_orders)
        
        // Initialize RecyclerView
        recyclerView = findViewById(R.id.rvOrders)
        recyclerView.layoutManager = LinearLayoutManager(this)
        
        // Initialize adapter with empty list
        adapter = OrderAdapter(emptyList()) { order ->
            navigateToOrderDetails(order)
        }
        recyclerView.adapter = adapter
        
        // Initialize ViewModel
        val database = AppDatabase.getDatabase(this)
        val orderDao = database.orderDao()
        val factory = OrderViewModelFactory(orderDao)
        viewModel = ViewModelProvider(this, factory)[OrderViewModel::class.java]
        
        // Observe orders from ViewModel
        viewModel.allOrders.observe(this) { orders ->
            updateAdapterData(orders)
        }
    }
    
    private fun updateAdapterData(orders: List<Order>) {
        // Create new adapter instance with updated data
        adapter = OrderAdapter(orders) { order ->
            navigateToOrderDetails(order)
        }
        recyclerView.adapter = adapter
    }
    
    private fun navigateToOrderDetails(order: Order) {
        val intent = Intent(this, OrderDetailsActivity::class.java)
        intent.putExtra("ORDER_ID", order.orderId)
        startActivity(intent)
    }
}
```

---

#### **Enhanced Adapter with DiffUtil (Optional)**

```kotlin
class OrderAdapter(
    private var orders: List<Order>,
    private val onViewDetailsClick: (Order) -> Unit
) : RecyclerView.Adapter<OrderAdapter.OrderViewHolder>() {
    
    fun updateOrders(newOrders: List<Order>) {
        val diffCallback = OrderDiffCallback(orders, newOrders)
        val diffResult = DiffUtil.calculateDiff(diffCallback)
        
        orders = newOrders
        diffResult.dispatchUpdatesTo(this)
    }
    
    // ... rest of adapter implementation
}

class OrderDiffCallback(
    private val oldList: List<Order>,
    private val newList: List<Order>
) : DiffUtil.Callback() {
    
    override fun getOldListSize() = oldList.size
    override fun getNewListSize() = newList.size
    
    override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int) =
        oldList[oldItemPosition].orderId == newList[newItemPosition].orderId
    
    override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int) =
        oldList[oldItemPosition] == newList[newItemPosition]
}
```

---

## üìä Marking Scheme Summary

### **Question Distribution (100 Marks Total)**

| Question | Part | Marks | Subtotal |
|----------|------|-------|----------|
| **Q1** | MCQ (10) | 1 each | **10** |
| **Q1** | Short Answer (10) | 1.5 each | **15** |
| **Q2** | Evaluation & Recommendation | 10 | **25** |
| **Q2** | Color Rule Application | 7 | |
| **Q2** | UI Elements | 8 | |
| **Q3** | Data Class | 5 | **25** |
| **Q3** | Sealed Class & Function | 10 | |
| **Q3** | Form Validation | 10 | |
| **Q4** | Order Data Class | 5 | **25** |
| **Q4** | OrderAdapter | 12 | |
| **Q4** | OrderViewModel | 8 | |
| | | | **Total: 100** |

---

## üéØ Key Concepts Tested

### **Knowledge Areas**
- ‚úÖ Android Architecture & Lifecycle
- ‚úÖ Kotlin Language Features
- ‚úÖ UI/UX Design Principles
- ‚úÖ Data Management (Room, ViewModel)
- ‚úÖ RecyclerView Implementation
- ‚úÖ Input Validation

### **Skills Assessed**
- üéì Theoretical Understanding
- üíª Practical Implementation
- üé® Design Thinking
- üìä Data Structures
- üîç Problem-Solving

---

## üìö Additional Resources

### **Recommended Reading**
- Android Architecture Components Documentation
- Kotlin Official Documentation
- Material Design Guidelines (60-30-10 Color Rule)
- Room Database Best Practices

### **Practice Tasks**
1. Implement the Product List screen with RecyclerView
2. Create a shopping cart management system
3. Build checkout flow with validation
4. Integrate Room database with ViewModel
5. Design color schemes using 60-30-10 rule

---

**Exam Preparation Tips:**
- ‚úÖ Practice all Kotlin examples thoroughly
- ‚úÖ Understand lifecycle methods deeply
- ‚úÖ Master RecyclerView implementation
- ‚úÖ Review UI/UX design principles
- ‚úÖ Practice Room database operations
- ‚úÖ Test your code extensively

---

**Last Updated:** November 14, 2025
**Subject:** IT2010 - Mobile Application Development
**Level:** Final Examination

---
