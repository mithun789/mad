# IT2010 - MOBILE APPLICATION DEVELOPMENT
## FINAL EXAMINATION - MODEL ANSWER SHEET

---

## QUESTION 01 - Knowledge Assessment (25 Marks)

### Part A: Multiple Choice Questions (10 Marks)

**1. C) Linux Kernel**
- The Linux Kernel layer contains all essential hardware drivers including camera, keyboard, display, etc.

**2. A) onCreate() → onStart() → onResume()**
- This is the correct sequence when an app launches from stopped state.

**3. B, C (Multiple answers)**
- B) Easier data sharing with ViewModel ✓
- C) Smoother navigation ✓
- Fragments allow better UI management and data sharing within a single Activity.

**4. C) Accent color for highlights and buttons**
- In 60-30-10 rule: 60% primary (background), 30% secondary, 10% accent (buttons, highlights)

**5. B) ?**
- The question mark (?) suffix makes a variable nullable in Kotlin: `var name: String?`

**6. B) Contains resource IDs for all resources**
- R.java is auto-generated by AAPT and provides IDs for accessing resources programmatically.

**7. B) onStop()**
- onStop() is called when the activity is no longer visible to the user.

**8. B) DVM uses JIT compilation, ART uses AOT**
- DVM: Just-In-Time compilation at runtime
- ART: Ahead-Of-Time compilation during installation

**9. B) Explicit Intent**
- Explicit Intents specify the exact component (Activity/Service) by class name.

**10. A) getItemCount()**
- This method returns the total number of items in the RecyclerView adapter's dataset.

---

### Part B: Short Answer Questions (15 Marks)

**1.** Android Asset Packaging Tool

**2.** observe() or observe(lifecycleOwner, Observer)

**3.** val

**4.** Vertical

**5.** onDestroy()

**6.** @Insert

**7.** Valid or ValidationResult.Valid

**8.** Service

**9.** onCreateView()

**10.** Mainstreamers

---

## QUESTION 02 - UI/UX Design and Analysis (25 Marks)

### a) Evaluation and Recommendation (10 Marks)

**Evaluation of Approach A (Feature-Rich Dashboard):**

**Disadvantages:**
- Overwhelming for mainstream users who represent the majority
- Violates simplicity principles - complexity makes it unsustainable
- Difficult to use in mobile environments (busy streets, one-handed use, quick tasks)
- Creates cognitive overload - users must process 12 options before taking action
- Poor emotional experience - users feel stressed rather than organized
- Designed for experts, not the mainstream majority
- Increased development and maintenance costs

**Advantages:**
- All features immediately visible
- May appeal to tech-savvy users who want quick access to everything

---

**Evaluation of Approach B (Simple Home Screen):**

**Advantages:**
- Follows simplicity principles - focuses on core user needs
- Designed for mainstreamers (majority users) who "just want the app to work"
- Reduces cognitive load - users see only what matters most
- Better for mobile environments (outdoor shopping, quick in-store use)
- Emotional benefit - users feel organized and in control, not overwhelmed
- Easier navigation - fewer taps to complete primary tasks
- Follows industry best practices (progressive disclosure)
- Lower maintenance costs and cleaner codebase

**Disadvantages:**
- Additional features require extra navigation step
- May frustrate expert users initially

---

**RECOMMENDATION: Approach B (Simple Home Screen)** ✅

**Justification:**

1. **Mainstream User Focus:** The majority of grocery shoppers are mainstreamers who want efficiency. They need to search products, manage their cart, track orders, and browse categories - these 4 features cover 90% of use cases.

2. **Mobile Context Consideration:**
   - **In-store usage:** Users need quick product lookup and cart access while shopping
   - **At home:** Users want to browse and plan orders without distraction
   - **Time-constrained:** Busy professionals need fast task completion

3. **Emotional Needs:** Shopping should feel simple and stress-free. A cluttered interface creates anxiety, especially for elderly users. Approach B provides clarity and confidence.

4. **Progressive Disclosure:** Advanced features (Loyalty Points, Store Locator, Recipes) are available through a menu for those who need them, without cluttering the main interface.

5. **Business Value:** Higher user satisfaction leads to better retention and more completed purchases. Users who feel overwhelmed abandon apps.

6. **Evidence-Based:** As stated in lectures - "Mass appeal comes from focusing on the mainstream." The Model T succeeded by serving the majority, not the experts.

---

### b) 60-30-10 Color Rule Application (7 Marks)

**Primary Color (60%) - Background and Main Surfaces:**
- **Choice:** Soft white or light gray (#F5F5F5)
- **Usage:** App background, product card backgrounds, main content areas
- **Reasoning:** 
  - Creates clean, uncluttered space for product images to stand out
  - Reduces eye strain during extended browsing
  - Communicates freshness and cleanliness (appropriate for groceries)
  - Ensures product photos display accurately without color interference

**Secondary Color (30%) - Supporting Elements:**
- **Choice:** Fresh green (#4CAF50) or warm orange (#FF9800)
- **Usage:** Navigation bars, section headers, category labels, price tags
- **Reasoning:**
  - Green suggests freshness, health, organic products (grocery context)
  - Orange creates warmth and appetite appeal
  - Provides visual hierarchy without overwhelming users
  - Guides attention to important information zones
  - Maintains readability with sufficient contrast

**Accent Color (10%) - Interactive Elements:**
- **Choice:** Vibrant complementary color (e.g., bright orange #FF5722 if primary is green, or teal #00BCD4 if primary is orange)
- **Usage:** 
  - "Add to Cart" buttons
  - "Checkout" button
  - Special offers/deals badges
  - Notification dots
  - Selected state indicators
- **Reasoning:**
  - Creates clear call-to-action that drives conversions
  - High contrast draws eye to critical interactive elements
  - Used sparingly to avoid visual noise
  - Creates sense of urgency for promotional items
  - Guides user through shopping journey

**Impact on User Experience:**
- **Clarity:** Strong contrast between background and interactive elements prevents confusion
- **Efficiency:** Users quickly identify where to click/tap
- **Emotional Response:** Color harmony creates pleasant, trustworthy shopping environment
- **Brand Recognition:** Consistent color usage builds familiarity
- **Accessibility:** Proper contrast ratios ensure readability for all users including those with visual impairments

---

### c) Five UI Elements for Product Card (8 Marks)

**1. ImageView - Product Photo**
- **Purpose:** Display high-quality product image
- **Justification:** Visual recognition is crucial for grocery shopping. Users need to see what they're buying. Images convey freshness, packaging, and size better than text. Mainstream users rely heavily on visual cues rather than reading descriptions.
- **Accessibility:** Include content description for screen readers

**2. TextView - Product Name & Description**
- **Purpose:** Display product title and brief description (e.g., "Organic Bananas - 1kg")
- **Justification:** Provides essential information for identification. Must be clear, readable font size (minimum 16sp) for elderly users. Brief description reduces need to open detailed view for basic info.
- **Accessibility:** High contrast text (dark on light) ensures readability in various lighting conditions

**3. TextView - Price Display**
- **Purpose:** Show current price (bold, prominent)
- **Justification:** Price is primary decision factor. Must be immediately visible without clicking. Use accent color or bold text to highlight deals. Include currency symbol. For mainstream users, price visibility builds trust and speeds decision-making.
- **Accessibility:** Large text size (18-20sp) for easy reading

**4. Button/ImageButton - "Add to Cart"**
- **Purpose:** Quick action to add product to shopping cart
- **Justification:** Enables one-tap purchase intent without navigating away. Critical for mobile shopping efficiency - users shopping in-store need speed. Icon (cart + plus sign) with accent color creates clear visual affordance. Reduces friction in purchase journey.
- **Accessibility:** Large touch target (minimum 48dp) for easy tapping, especially for elderly users or outdoor use

**5. ImageButton/ToggleButton - "Add to Favorites/Wishlist"**
- **Purpose:** Save products for later (heart icon)
- **Justification:** Users often browse before buying. Favorites allow comparison and future reference without immediate purchase pressure. Emotional benefit - users feel organized and in control. Toggle state (filled/outline heart) provides clear feedback.
- **Accessibility:** Sufficient spacing from other buttons to prevent mis-taps, clear visual state changes

**Additional Justifications Across All Elements:**
- **Mobile Environment:** All elements sized for finger-friendly interaction (outdoor use, gloved hands in winter)
- **Scanning Pattern:** Layout follows F-pattern reading - image top, name/price middle, actions bottom
- **Cognitive Load:** Limited information prevents overwhelming mainstream users
- **Performance:** Simple elements ensure fast scrolling through long product lists

---

## QUESTION 03 - Kotlin Development and Form Validation (25 Marks)

### a) Product Data Class (5 Marks)

```kotlin
data class Product(
    val productId: String,
    val name: String,
    val price: Double,
    val category: String,
    val stockQuantity: Int,
    val imageUrl: String = "",
    val description: String = ""
)
```

**Explanation:**
- `productId`: Unique identifier (String for flexibility like "PROD001")
- `name`: Product name (String)
- `price`: Product price (Double for decimal values)
- `category`: Product category for filtering (String like "Fruits", "Dairy")
- `stockQuantity`: Available quantity (Int for counting)
- `imageUrl`: Optional with default empty string
- `description`: Optional product details with default value

**Alternative Solution:**
```kotlin
data class Product(
    val id: Int = 0,
    val productName: String,
    val unitPrice: Double,
    val categoryName: String,
    val availableStock: Int,
    val brand: String = "Generic",
    val expiryDate: String = ""
)
```

---

### b) OrderStatus Sealed Class (10 Marks)

```kotlin
sealed class OrderStatus {
    object Pending : OrderStatus()
    data class Shipped(val trackingNumber: String) : OrderStatus()
    data class Delivered(val deliveryDate: String) : OrderStatus()
}

fun getOrderStatusMessage(status: OrderStatus): String {
    return when (status) {
        is OrderStatus.Pending -> 
            "Your order has been received and is being processed. We'll notify you once it ships."
        
        is OrderStatus.Shipped -> 
            "Your order is on the way! Track it using: ${status.trackingNumber}"
        
        is OrderStatus.Delivered -> 
            "Your order was delivered on ${status.deliveryDate}. Thank you for shopping with us!"
    }
}
```

**Explanation:**
- **Sealed Class:** Restricts inheritance - all subclasses must be defined in same file
- **Object Pending:** Singleton object - no additional data needed
- **Data Classes:** Shipped and Delivered carry additional information
- **When Expression:** Exhaustive - compiler ensures all cases handled
- **Smart Casting:** `status.trackingNumber` accessible due to `is` check

**Usage Example:**
```kotlin
// Example usage
val order1 = OrderStatus.Pending
println(getOrderStatusMessage(order1))
// Output: Your order has been received and is being processed...

val order2 = OrderStatus.Shipped("TRK123456789")
println(getOrderStatusMessage(order2))
// Output: Your order is on the way! Track it using: TRK123456789

val order3 = OrderStatus.Delivered("2025-11-14")
println(getOrderStatusMessage(order3))
// Output: Your order was delivered on 2025-11-14...
```

---

### c) Checkout Form Validation (10 Marks)

```kotlin
sealed class ValidationResult {
    data class Empty(val errorMessage: String) : ValidationResult()
    data class Invalid(val errorMessage: String) : ValidationResult()
    object Valid : ValidationResult()
}

class CheckoutFormData(
    private val phoneNumber: String,
    private val address: String,
    private val postalCode: String
) {
    
    fun validatePhoneNumber(): ValidationResult {
        return when {
            phoneNumber.isEmpty() -> {
                ValidationResult.Empty("Phone number is required")
            }
            !phoneNumber.startsWith("07") -> {
                ValidationResult.Invalid("Phone number must start with 07")
            }
            phoneNumber.length < 10 -> {
                ValidationResult.Invalid("Phone number must be exactly 10 digits")
            }
            phoneNumber.length > 10 -> {
                ValidationResult.Invalid("Phone number must be exactly 10 digits")
            }
            !phoneNumber.all { it.isDigit() } -> {
                ValidationResult.Invalid("Phone number must contain only digits")
            }
            else -> {
                ValidationResult.Valid
            }
        }
    }
    
    fun validateAddress(): ValidationResult {
        return when {
            address.isEmpty() -> {
                ValidationResult.Empty("Delivery address is required")
            }
            address.trim().length < 10 -> {
                ValidationResult.Invalid("Address must be at least 10 characters long")
            }
            else -> {
                ValidationResult.Valid
            }
        }
    }
    
    fun validatePostalCode(): ValidationResult {
        return when {
            postalCode.isEmpty() -> {
                ValidationResult.Empty("Postal code is required")
            }
            postalCode.length != 5 -> {
                ValidationResult.Invalid("Postal code must be exactly 5 digits")
            }
            !postalCode.all { it.isDigit() } -> {
                ValidationResult.Invalid("Postal code must contain only digits")
            }
            else -> {
                ValidationResult.Valid
            }
        }
    }
}
```

**Usage in Activity:**
```kotlin
// Example usage in button click
fun submitCheckout(view: View) {
    val formData = CheckoutFormData(
        phoneNumber = edtPhone.text.toString(),
        address = edtAddress.text.toString(),
        postalCode = edtPostalCode.text.toString()
    )
    
    var validCount = 0
    
    // Validate phone number
    when (val phoneValidation = formData.validatePhoneNumber()) {
        is ValidationResult.Valid -> validCount++
        is ValidationResult.Invalid -> edtPhone.error = phoneValidation.errorMessage
        is ValidationResult.Empty -> edtPhone.error = phoneValidation.errorMessage
    }
    
    // Validate address
    when (val addressValidation = formData.validateAddress()) {
        is ValidationResult.Valid -> validCount++
        is ValidationResult.Invalid -> edtAddress.error = addressValidation.errorMessage
        is ValidationResult.Empty -> edtAddress.error = addressValidation.errorMessage
    }
    
    // Validate postal code
    when (val postalValidation = formData.validatePostalCode()) {
        is ValidationResult.Valid -> validCount++
        is ValidationResult.Invalid -> edtPostalCode.error = postalValidation.errorMessage
        is ValidationResult.Empty -> edtPostalCode.error = postalValidation.errorMessage
    }
    
    if (validCount == 3) {
        Toast.makeText(this, "Checkout successful!", Toast.LENGTH_SHORT).show()
        // Proceed to payment
    }
}
```

---

## QUESTION 04 - Kotlin Development and RecyclerView (25 Marks)

### a) Order Data Class (5 Marks)

```kotlin
data class Order(
    val orderId: String,
    val orderDate: String,
    val totalAmount: Double,
    val orderStatus: String,
    val items: Int = 0
)
```

**Alternative with more details:**
```kotlin
data class Order(
    val id: Int = 0,
    val orderId: String,
    val orderDate: String,
    val totalAmount: Double,
    val status: String, // "Pending", "Shipped", "Delivered"
    val itemCount: Int,
    val deliveryAddress: String = ""
)
```

---

### b) OrderAdapter Implementation (12 Marks)

```kotlin
class OrderAdapter(
    private val orders: List,
    private val onViewDetailsClick: (Order) -> Unit
) : RecyclerView.Adapter() {
    
    inner class OrderViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val tvOrderId: TextView = view.findViewById(R.id.tvOrderId)
        val tvOrderDate: TextView = view.findViewById(R.id.tvOrderDate)
        val tvTotalAmount: TextView = view.findViewById(R.id.tvTotalAmount)
        val tvOrderStatus: TextView = view.findViewById(R.id.tvOrderStatus)
        val btnViewDetails: Button = view.findViewById(R.id.btnViewDetails)
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): OrderViewHolder {
        val layoutInflater = LayoutInflater.from(parent.context)
        val view = layoutInflater.inflate(R.layout.item_order, parent, false)
        return OrderViewHolder(view)
    }
    
    override fun onBindViewHolder(holder: OrderViewHolder, position: Int) {
        val order = orders[position]
        
        holder.tvOrderId.text = "Order #${order.orderId}"
        holder.tvOrderDate.text = order.orderDate
        holder.tvTotalAmount.text = "Rs. ${String.format("%.2f", order.totalAmount)}"
        holder.tvOrderStatus.text = order.orderStatus
        
        // Set status color based on order status
        when (order.orderStatus) {
            "Pending" -> holder.tvOrderStatus.setTextColor(Color.parseColor("#FF9800"))
            "Shipped" -> holder.tvOrderStatus.setTextColor(Color.parseColor("#2196F3"))
            "Delivered" -> holder.tvOrderStatus.setTextColor(Color.parseColor("#4CAF50"))
        }
        
        holder.btnViewDetails.setOnClickListener {
            onViewDetailsClick(order)
        }
    }
    
    override fun getItemCount(): Int {
        return orders.size
    }
}
```

**Usage in Activity/Fragment:**
```kotlin
class OrdersActivity : AppCompatActivity() {
    
    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: OrderAdapter
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_orders)
        
        recyclerView = findViewById(R.id.rvOrders)
        recyclerView.layoutManager = LinearLayoutManager(this)
        
        // Sample data
        val orders = listOf(
            Order("ORD001", "2025-11-14", 2450.50, "Delivered"),
            Order("ORD002", "2025-11-13", 1890.00, "Shipped"),
            Order("ORD003", "2025-11-12", 3200.75, "Pending")
        )
        
        adapter = OrderAdapter(orders) { order ->
            // Handle view details click
            Toast.makeText(this, "Viewing details for ${order.orderId}", Toast.LENGTH_SHORT).show()
            // Navigate to order details screen
            val intent = Intent(this, OrderDetailsActivity::class.java)
            intent.putExtra("ORDER_ID", order.orderId)
            startActivity(intent)
        }
        
        recyclerView.adapter = adapter
    }
}
```

**Alternative with DiffUtil for better performance:**
```kotlin
class OrderAdapter(
    private var orders: List,
    private val onViewDetailsClick: (Order) -> Unit
) : RecyclerView.Adapter() {
    
    fun updateOrders(newOrders: List) {
        orders = newOrders
        notifyDataSetChanged()
    }
    
    // ... rest of the implementation
}
```

---

### c) OrderViewModel Implementation (8 Marks)

```kotlin
class OrderViewModel(private val orderDao: OrderDao) : ViewModel() {
    
    fun getAllOrdersSortedByDate(): LiveData<List> {
        return orderDao.getAllOrdersSortedByDate()
    }
    
    // Additional useful functions
    fun getOrdersByStatus(status: String): LiveData<List> {
        return orderDao.getOrdersByStatus(status)
    }
    
    fun searchOrders(query: String): LiveData<List> {
        return orderDao.searchOrders("%$query%")
    }
}
```

**Complete implementation with ViewModelFactory:**
```kotlin
// ViewModel with Factory
class OrderViewModel(private val orderDao: OrderDao) : ViewModel() {
    
    // Get all orders sorted by date
    val allOrders: LiveData<List> = orderDao.getAllOrdersSortedByDate()
    
    // Get orders by status
    fun getOrdersByStatus(status: String): LiveData<List> {
        return orderDao.getOrdersByStatus(status)
    }
    
    // Search orders
    fun searchOrders(searchQuery: String): LiveData<List> {
        return orderDao.searchOrders("%$searchQuery%")
    }
    
    // Insert new order
    fun insertOrder(order: Order) {
        viewModelScope.launch(Dispatchers.IO) {
            orderDao.insertOrder(order)
        }
    }
}

// ViewModelFactory
class OrderViewModelFactory(private val orderDao: OrderDao) : ViewModelProvider.Factory {
    override fun  create(modelClass: Class): T {
        if (modelClass.isAssignableFrom(OrderViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return OrderViewModel(orderDao) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
```

**Complete DAO Interface:**
```kotlin
@Dao
interface OrderDao {
    
    @Query("SELECT * FROM orders ORDER BY orderDate DESC")
    fun getAllOrdersSortedByDate(): LiveData<List>
    
    @Query("SELECT * FROM orders WHERE orderStatus = :status ORDER BY orderDate DESC")
    fun getOrdersByStatus(status: String): LiveData<List>
    
    @Query("SELECT * FROM orders WHERE orderId LIKE :query ORDER BY orderDate DESC")
    fun searchOrders(query: String): LiveData<List>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrder(order: Order)
    
    @Delete
    suspend fun deleteOrder(order: Order)
    
    @Query("SELECT * FROM orders WHERE orderId = :orderId")
    suspend fun getOrderById(orderId: String): Order?
}
```

**Usage in Activity:**
```kotlin
class OrdersActivity : AppCompatActivity() {
    
    private lateinit var viewModel: OrderViewModel
    private lateinit var adapter: OrderAdapter
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_orders)
        
        // Initialize RecyclerView
        val recyclerView: RecyclerView = findViewById(R.id.rvOrders)
        recyclerView.layoutManager = LinearLayoutManager(this)
        
        // Initialize adapter
        adapter = OrderAdapter(emptyList()) { order ->
            // Handle view details click
            val intent = Intent(this, OrderDetailsActivity::class.java)
            intent.putExtra("ORDER_ID", order.orderId)
            startActivity(intent)
        }
        recyclerView.adapter = adapter
        
        // Initialize ViewModel
        val database = AppDatabase.getDatabase(this)
        val orderDao = database.orderDao()
        val factory = OrderViewModelFactory(orderDao)
        viewModel = ViewModelProvider(this, factory)[OrderViewModel::class.java]
        
        // Observe orders
        viewModel.allOrders.observe(this) { orders ->
            adapter.updateOrders(orders)
        }
    }
}
```

**Entity Definition (Required for Room):**
```kotlin
@Entity(tableName = "orders")
data class Order(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    
    @ColumnInfo(name = "orderId")
    val orderId: String,
    
    @ColumnInfo(name = "orderDate")
    val orderDate: String,
    
    @ColumnInfo(name = "totalAmount")
    val totalAmount: Double,
    
    @ColumnInfo(name = "orderStatus")
    val orderStatus: String
)
```

---

## END OF MODEL ANSWERS

### Marking Scheme Summary:

**Question 1 (25 marks):**
- Part A MCQs: 1 mark each × 10 = 10 marks
- Part B Short Answers: 1.5 marks each × 10 = 15 marks

**Question 2 (25 marks):**
- Part a: 10 marks (Evaluation 6, Recommendation 4)
- Part b: 7 marks (Color choices and justification)
- Part c: 8 marks (5 elements with justifications)

**Question 3 (25 marks):**
- Part a: 5 marks (Data class with 5+ properties)
- Part b: 10 marks (Sealed class 5, Function 5)
- Part c: 10 marks (Validation class with 3 functions)

**Question 4 (25 marks):**
- Part a: 5 marks (Order data class)
- Part b: 12 marks (ViewHolder 3, Constructor 2, Methods 7)
- Part c: 8 marks (ViewModel implementation with DAO usage)

**Total: 100 marks**